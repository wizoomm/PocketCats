-- ============================================================================
-- СТРУКТУРА БАЗЫ ДАННЫХ
-- ============================================================================

-- Типы данных
CREATE TYPE tile_type AS ENUM ('cat', 'prey');
CREATE TYPE tile_status AS ENUM ('closed', 'opened');

-- Таблица пользователей
CREATE TABLE users (
    login TEXT PRIMARY KEY,
    password TEXT NOT NULL
);

-- Таблица токенов авторизации
CREATE TABLE user_tokens (
    login TEXT NOT NULL REFERENCES users(login) ON DELETE CASCADE,
    token TEXT PRIMARY KEY,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Таблица кланов
CREATE TABLE clans (
    clanName VARCHAR(50) PRIMARY KEY
);

-- Таблица тайлов (все доступные тайлы в системе)
CREATE TABLE tiles (
    tileID SERIAL PRIMARY KEY,
    type tile_type NOT NULL,
    power INT NOT NULL
);

-- Связь тайлов с кланами (для котов)
CREATE TABLE tilesclans (
    tileID INT NOT NULL REFERENCES tiles(tileID) ON DELETE CASCADE,
    clanName VARCHAR(50) NOT NULL REFERENCES clans(clanName) ON DELETE CASCADE,
    PRIMARY KEY (tileID, clanName)
);

-- Таблица игр
CREATE TABLE games (
    gameID SERIAL PRIMARY KEY,
    stepTime INT DEFAULT 30,
    started_at TIMESTAMP,
    finished_at TIMESTAMP
);

-- Таблица игроков
CREATE TABLE players (
    playerID SERIAL PRIMARY KEY,
    login TEXT NOT NULL REFERENCES users(login) ON DELETE CASCADE,
    gameID INT NOT NULL REFERENCES games(gameID) ON DELETE CASCADE,
    clan VARCHAR(50) NOT NULL REFERENCES clans(clanName),
    playerNumber INT NOT NULL CHECK (playerNumber IN (1, 2)),
    playerPoints INT DEFAULT 0,
    UNIQUE(gameID, playerNumber),
    UNIQUE(gameID, login)
);

-- Таблица тайлов в играх (расположение тайлов на поле)
CREATE TABLE tilesingames (
    tileInGameID SERIAL PRIMARY KEY,
    gameID INT NOT NULL REFERENCES games(gameID) ON DELETE CASCADE,
    tileID INT NOT NULL REFERENCES tiles(tileID),
    coordinateX INT NOT NULL,
    coordinateY INT NOT NULL,
    status tile_status DEFAULT 'closed',
    UNIQUE(gameID, coordinateX, coordinateY)
);

-- Таблица ходов
CREATE TABLE moves (
    moveID SERIAL PRIMARY KEY,
    playerID INT NOT NULL REFERENCES players(playerID) ON DELETE CASCADE,
    begin TIMESTAMP DEFAULT NOW(),
    openedTile INT REFERENCES tilesingames(tileInGameID)
);

-- Таблица текущих открытых тайлов (для отслеживания активного тайла игрока)
CREATE TABLE current_open_tiles (
    gameID INT NOT NULL REFERENCES games(gameID) ON DELETE CASCADE,
    playerID INT NOT NULL REFERENCES players(playerID) ON DELETE CASCADE,
    tileInGameID INT NOT NULL REFERENCES tilesingames(tileInGameID) ON DELETE CASCADE,
    PRIMARY KEY (gameID, playerID)
);

-- Индексы для оптимизации
CREATE INDEX idx_user_tokens_token ON user_tokens(token);
CREATE INDEX idx_players_gameid ON players(gameID);
CREATE INDEX idx_tilesingames_gameid ON tilesingames(gameID);
CREATE INDEX idx_tilesingames_coords ON tilesingames(gameID, coordinateX, coordinateY);
CREATE INDEX idx_moves_playerid ON moves(playerID);
CREATE INDEX idx_moves_gameid ON moves(playerID) WHERE playerID IN (SELECT playerID FROM players);

-- ============================================================================
-- ХРАНИМЫЕ ПРОЦЕДУРЫ
-- ============================================================================

-- 1. authorize_user 

CREATE OR REPLACE FUNCTION authorize_user(p_login TEXT, p_password TEXT)
RETURNS JSON 
SECURITY DEFINER
AS $$
DECLARE
    stored_password TEXT;
    pass_hash       TEXT;
    new_token       TEXT;
BEGIN
    -- Берём пароль пользователя
    SELECT password
    INTO stored_password
    FROM users
    WHERE login = p_login;

    IF stored_password IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'User not found'
        );
    END IF;

    -- Хешируем введённый пароль
    pass_hash := md5(p_password);

    IF stored_password <> pass_hash THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Wrong password'
        );
    END IF;

    -- Генерируем токен и сохраняем
    new_token := md5(
        random()::text || clock_timestamp()::text || p_login
    );

    INSERT INTO user_tokens (login, token, created_at)
    VALUES (p_login, new_token, NOW());

    RETURN json_build_object(
        'status',  'success',
        'message', 'User authorized',
        'token',   new_token
    );
END;
$$ LANGUAGE plpgsql;







-- 2. register_user — регистрация + сразу токен

CREATE OR REPLACE FUNCTION register_user(p_login TEXT, p_password TEXT)
RETURNS JSON 
SECURITY DEFINER
AS $$
DECLARE
    pass_hash TEXT;
BEGIN
    -- Логин занят?
    IF EXISTS (SELECT 1 FROM users WHERE login = p_login) THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Nickname taken'
        );
    END IF;

    -- Минимальные проверки длины
    IF LENGTH(p_login) < 3 THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Short nickname'
        );
    END IF;

    IF LENGTH(p_password) < 3 THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Short password'
        );
    END IF;

    -- Хешируем пароль и сохраняем 
    pass_hash := md5(p_password);

    INSERT INTO users (login, password)
    VALUES (p_login, pass_hash);

    -- Сразу авторизуем
    RETURN authorize_user(p_login, p_password);
END;
$$ LANGUAGE plpgsql;






-- 3. logout_user — выйти из аккаунта

CREATE OR REPLACE FUNCTION logout_user(p_token TEXT)
RETURNS JSON 
SECURITY DEFINER
AS $$
DECLARE
    v_login TEXT;
BEGIN
    -- Проверяем, существует ли токен
    SELECT login
    INTO v_login
    FROM user_tokens
    WHERE token = p_token;

    IF v_login IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Invalid token'
        );
    END IF;

    -- Удаляем токен (только этот)
    DELETE FROM user_tokens
    WHERE token = p_token;

    -- Возвращаем успешный ответ
    RETURN json_build_object(
        'status',  'success',
        'message', format('User %s has been logged out successfully.', v_login)
    );
END;
$$ LANGUAGE plpgsql;









-- 4. create_room — создать игру (комнату)

CREATE OR REPLACE FUNCTION create_room(p_user_token TEXT, p_step_time INT DEFAULT 30)
RETURNS JSON
SECURITY DEFINER
AS $$
DECLARE
    v_login      TEXT;
    v_game_id    INT;
    v_clan       VARCHAR(50);
    v_board_size INT := 5;   -- размер поля 5x5
    v_tile_count INT;
BEGIN
    -- 0. Логин по токену
    SELECT login
    INTO v_login
    FROM user_tokens
    WHERE token = p_user_token;

    IF v_login IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Invalid token'
        );
    END IF;

    -- 1. Проверяем, что в таблице tiles достаточно тайлов для поля 5x5
    SELECT COUNT(*) INTO v_tile_count FROM tiles;

    IF v_tile_count < v_board_size * v_board_size THEN
        RETURN json_build_object(
            'status',  'error',
            'message', format(
                'Not enough tiles: need %s, but only %s in tiles',
                v_board_size * v_board_size, v_tile_count
            )
        );
    END IF;

    -- 2. Создаём игру
    INSERT INTO games (stepTime)
    VALUES (p_step_time)
    RETURNING gameID INTO v_game_id;

    -- 3. Случайный клан для создателя
    SELECT clanName
    INTO v_clan
    FROM clans
    ORDER BY random()
    LIMIT 1;

    -- 4. Создатель = первый игрок
    INSERT INTO players (login, gameID, clan, playerNumber, playerPoints)
    VALUES (v_login, v_game_id, v_clan, 1, 0);

    -- 5. Раскладываем тайлы в таблицу tilesingames
    --    Берём все tiles в случайном порядке, первым 25 даём координаты поля 5x5.
    INSERT INTO tilesingames (gameID, tileID, coordinateX, coordinateY, status)
    SELECT
        v_game_id                                          AS gameID,
        t.tileID                                           AS tileID,
        ((rn - 1) % v_board_size)                          AS coordinateX,
        ((rn - 1) / v_board_size)                          AS coordinateY,
        'closed'::tile_status                              AS status
    FROM (
        SELECT
            tileID,
            ROW_NUMBER() OVER (ORDER BY random()) AS rn
        FROM tiles
    ) t
    WHERE t.rn <= v_board_size * v_board_size;

    -- 6. Возвращаем JSON-ответ
    RETURN json_build_object(
        'status',      'success',
        'message',     'Room created',
        'game_id',     v_game_id,
        'owner',       v_login,
        'owner_clan',  v_clan
    );
END;
$$ LANGUAGE plpgsql;











-- 5. join_room — присоединиться к существующей игре, при входе 2-го игрока стартуем игру (started_at = now())

CREATE OR REPLACE FUNCTION join_room(p_user_token TEXT, p_game_id INT)
RETURNS JSON
SECURITY DEFINER
AS $$
DECLARE
    v_login        TEXT;
    v_existing_id  INT;
    v_player_count INT;
    v_next_number  INT;
    v_clan         VARCHAR(50);
BEGIN
    SELECT login
    INTO v_login
    FROM user_tokens
    WHERE token = p_user_token;

    IF v_login IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Invalid token'
        );
    END IF;

    PERFORM 1 FROM games WHERE gameID = p_game_id;
    IF NOT FOUND THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Game not found'
        );
    END IF;

    SELECT playerID
    INTO v_existing_id
    FROM players
    WHERE gameID = p_game_id
      AND login  = v_login;

    IF v_existing_id IS NOT NULL THEN
        RETURN json_build_object(
            'status',  'success',
            'message', 'Already in this room'
        );
    END IF;

    SELECT COUNT(*)
    INTO v_player_count
    FROM players
    WHERE gameID = p_game_id;

    IF v_player_count >= 2 THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Room is full'
        );
    END IF;

    v_next_number := v_player_count + 1;

    SELECT clanName
    INTO v_clan
    FROM clans
    WHERE clanName NOT IN (
        SELECT pl.clan
        FROM players pl
        WHERE pl.gameID = p_game_id
    )
    ORDER BY random()
    LIMIT 1;

    IF v_clan IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'No alternative clans available'
        );
    END IF;

    INSERT INTO players (login, gameID, clan, playerNumber, playerPoints)
    VALUES (v_login, p_game_id, v_clan, v_next_number, 0);

    -- Если теперь игроков 2 — запускаем игру
    IF (SELECT COUNT(*) FROM players WHERE gameID = p_game_id) = 2 THEN
        UPDATE games
        SET started_at = now()
        WHERE gameID = p_game_id
          AND started_at IS NULL;
    END IF;

    RETURN json_build_object(
        'status',        'success',
        'message',       'Joined room',
        'player_number', v_next_number,
        'clan',          v_clan
    );
END;
$$ LANGUAGE plpgsql;












-- 6. open_tile — ОТКРЫТЬ ТАЙЛ ПО КООРДИНАТАМ 

CREATE OR REPLACE FUNCTION open_tile(
    p_token   TEXT,
    p_game_id INT,
    p_x       INT,
    p_y       INT
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_login              TEXT;
    v_player_id          INT;
    v_player_number      INT;
    v_expected_player_id INT;
    v_last_move_player   INT;

    v_type             tile_type;
    v_status           tile_status;
    v_x                INT;
    v_y                INT;
    v_tile_in_game_id  INT;
BEGIN

    IF EXISTS (
        SELECT 1 FROM games
        WHERE gameID = p_game_id
          AND finished_at IS NOT NULL
    ) THEN
        RETURN json_build_object(
            'status','error',
            'message','Игра окончена'
        );
    END IF;

    -- 1. Токен логин
    SELECT ut.login
    INTO v_login
    FROM user_tokens ut
    WHERE ut.token = p_token;

    IF v_login IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Invalid token'
        );
    END IF;

    -- 2. Игрок в этой игре
    SELECT p.playerID, p.playerNumber
    INTO v_player_id, v_player_number
    FROM players p
    WHERE p.gameID = p_game_id
      AND p.login  = v_login;

    IF v_player_id IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', format('Игрок %s не участвует в игре %s', v_login, p_game_id)
        );
    END IF;

    -- 3. Чей сейчас ход
    SELECT m.playerID
    INTO v_last_move_player
    FROM moves m
    JOIN players pl ON pl.playerID = m.playerID
    WHERE pl.gameID = p_game_id
    ORDER BY m.moveID DESC
    LIMIT 1;

    IF v_last_move_player IS NULL THEN
        SELECT playerID
        INTO v_expected_player_id
        FROM players
        WHERE gameID       = p_game_id
          AND playerNumber = 1;
    ELSE
        SELECT playerID
        INTO v_expected_player_id
        FROM players
        WHERE gameID       = p_game_id
          AND playerNumber = CASE
                                WHEN (SELECT playerNumber
                                      FROM players
                                      WHERE playerID = v_last_move_player) = 1
                                THEN 2
                                ELSE 1
                             END;
    END IF;

    IF v_player_id <> v_expected_player_id THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Сейчас не ваш ход'
        );
    END IF;

    -- 4. Находим тайл по координатам
    SELECT tig.tileInGameID,
           t.type,
           tig.status,
           tig.coordinateX,
           tig.coordinateY
    INTO v_tile_in_game_id, v_type, v_status, v_x, v_y
    FROM tilesingames tig
    JOIN tiles t ON t.tileID = tig.tileID
    WHERE tig.gameID     = p_game_id
      AND tig.coordinateX = p_x
      AND tig.coordinateY = p_y;

    IF v_tile_in_game_id IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', format('Тайл по координатам (%s,%s) не принадлежит игре %s', p_x, p_y, p_game_id)
        );
    END IF;

    IF v_status = 'opened' THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Этот тайл уже открыт'
        );
    END IF;

    -- 5. Открываем тайл
    UPDATE tilesingames
    SET status = 'opened'
    WHERE gameID       = p_game_id
      AND tileInGameID = v_tile_in_game_id;

    -- 6. Запоминаем, какой тайл сейчас «активный» для этого игрока
    INSERT INTO current_open_tiles (gameID, playerID, tileInGameID)
    VALUES (p_game_id, v_player_id, v_tile_in_game_id)
    ON CONFLICT (gameID, playerID)
    DO UPDATE SET tileInGameID = EXCLUDED.tileInGameID;

    RETURN json_build_object(
        'status',          'success',
        'tile_in_game_id', v_tile_in_game_id,
        'type',            v_type,
        'coordinateX',     v_x,
        'coordinateY',     v_y
    );
END;
$$;













-- 7. move_tile — ПЕРЕМЕСТИТЬ ТАЙЛ

CREATE OR REPLACE FUNCTION move_tile(
    p_token    TEXT,
    p_game_id  INT,
    p_target_x INT,
    p_target_y INT
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_login              TEXT;
    v_player_id          INT;
    v_player_number      INT;
    v_expected_player_id INT;
    v_last_move_player   INT;

    v_type   tile_type;
    v_status tile_status;
    v_x      INT;
    v_y      INT;

    v_board_size INT := 5;

    v_target_tile_in_game INT;
    v_actual_x            INT;
    v_actual_y            INT;

    v_move_id            INT;
    v_all_opened         BOOLEAN;
    v_tile_in_game_id    INT; -- «исходный» тайл, который двигаем
BEGIN


    IF EXISTS (
        SELECT 1 FROM games
        WHERE gameID = p_game_id
          AND finished_at IS NOT NULL
    ) THEN
        RETURN json_build_object(
            'status','error',
            'message','Игра окончена'
        );
    END IF;

    -- 0. Токен логин
    SELECT ut.login
    INTO v_login
    FROM user_tokens ut
    WHERE ut.token = p_token;

    IF v_login IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Invalid token'
        );
    END IF;

    -- 1. Игрок в этой игре
    SELECT p.playerID, p.playerNumber
    INTO v_player_id, v_player_number
    FROM players p
    WHERE p.gameID = p_game_id
      AND p.login  = v_login;

    IF v_player_id IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', format('Игрок %s не участвует в игре %s', v_login, p_game_id)
        );
    END IF;

    -- 2. Чей сейчас ход (по последнему полностью завершённому ходу)
    SELECT m.playerID
    INTO v_last_move_player
    FROM moves m
    JOIN players pl ON pl.playerID = m.playerID
    WHERE pl.gameID = p_game_id
    ORDER BY m.moveID DESC
    LIMIT 1;

    IF v_last_move_player IS NULL THEN
        SELECT playerID
        INTO v_expected_player_id
        FROM players
        WHERE gameID       = p_game_id
          AND playerNumber = 1;
    ELSE
        SELECT playerID
        INTO v_expected_player_id
        FROM players
        WHERE gameID       = p_game_id
          AND playerNumber = CASE
                                WHEN (SELECT playerNumber
                                      FROM players
                                      WHERE playerID = v_last_move_player) = 1
                                THEN 2
                                ELSE 1
                             END;
    END IF;

    IF v_player_id <> v_expected_player_id THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Сейчас не ваш ход'
        );
    END IF;

    -- 2.5. Берём «активный» тайл для этого игрока в этой игре
    SELECT cot.tileInGameID
    INTO v_tile_in_game_id
    FROM current_open_tiles cot
    WHERE cot.gameID   = p_game_id
      AND cot.playerID = v_player_id;

    IF v_tile_in_game_id IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Нет выбранного тайла: сначала откройте тайл (open_tile)'
        );
    END IF;

    -- 3. Информация о тайле, который двигаем
    SELECT t.type, tig.status, tig.coordinateX, tig.coordinateY
    INTO v_type, v_status, v_x, v_y
    FROM tilesingames tig
    JOIN tiles t ON t.tileID = tig.tileID
    WHERE tig.tileInGameID = v_tile_in_game_id
      AND tig.gameID      = p_game_id;

    IF v_type IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', format('Тайл %s не принадлежит игре %s', v_tile_in_game_id, p_game_id)
        );
    END IF;

    -- Требуем, чтобы тайл уже был открыт
    IF v_status <> 'opened' THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Сначала нужно открыть тайл (open_tile)'
        );
    END IF;

    -- 4. Грубая проверка выхода за поле
    IF p_target_x < 0 OR p_target_x >= v_board_size
       OR p_target_y < 0 OR p_target_y >= v_board_size THEN
        p_target_x := v_x;
        p_target_y := v_y;
    END IF;

    -- 5. Строго проверяем, что target_x/target_y это допустимая цель

IF v_type = 'prey' THEN
    -- Добыча: только соседние 8 клеток
    IF NOT (
        p_target_x BETWEEN v_x - 1 AND v_x + 1 AND
        p_target_y BETWEEN v_y - 1 AND v_y + 1 AND
        NOT (p_target_x = v_x AND p_target_y = v_y)
    ) THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Недопустимая цель для хода добычей'
        );
    END IF;

ELSIF v_type = 'cat' THEN
    -- Кот: строго на 1–2 клетки по горизонтали или вертикали
    IF NOT (
        (p_target_x = v_x AND ABS(p_target_y - v_y) IN (1, 2))
        OR
        (p_target_y = v_y AND ABS(p_target_x - v_x) IN (1, 2))
    ) THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Недопустимая цель для хода котом'
        );
    END IF;
END IF;

-- 5.1. Проверяем, что в этой точке стоит тайл
SELECT tig.tileInGameID
INTO v_target_tile_in_game
FROM tilesingames tig
WHERE tig.gameID = p_game_id
  AND tig.coordinateX = p_target_x
  AND tig.coordinateY = p_target_y;

IF v_target_tile_in_game IS NULL THEN
    RETURN json_build_object(
        'status',  'error',
        'message', 'В указанной клетке нет тайла'
    );
END IF;

v_actual_x := p_target_x;
v_actual_y := p_target_y;


    -- 6. Если нет доступных целей
    IF v_target_tile_in_game IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Нет доступных клеток для хода этим тайлом'
        );
    END IF;

    -- 7. Меняем координаты (обмен местами)
    UPDATE tilesingames
    SET coordinateX = -1,
        coordinateY = -1
    WHERE gameID       = p_game_id
      AND tileInGameID = v_tile_in_game_id;

    UPDATE tilesingames
    SET coordinateX = v_x,
        coordinateY = v_y
    WHERE gameID       = p_game_id
      AND tileInGameID = v_target_tile_in_game;

    UPDATE tilesingames
    SET coordinateX = v_actual_x,
        coordinateY = v_actual_y
    WHERE gameID       = p_game_id
      AND tileInGameID = v_tile_in_game_id;

    -- 8. Записываем ход
    INSERT INTO moves (playerID, begin, openedTile)
    VALUES (v_player_id, clock_timestamp(), v_tile_in_game_id)
    RETURNING moveID INTO v_move_id;

    -- 9. «Сбрасываем» активный тайл для этого игрока
    DELETE FROM current_open_tiles
    WHERE gameID = p_game_id
      AND playerID = v_player_id;

    -- 10. Проверяем, все ли тайлы открыты
    SELECT COUNT(*) = 0
    INTO v_all_opened
    FROM tilesingames
    WHERE gameID = p_game_id
      AND status = 'closed';

    IF v_all_opened THEN
        PERFORM finish_game(p_game_id);
    END IF;

    RETURN json_build_object(
        'status',      'ok',
        'move_id',     v_move_id,
        'all_opened',  v_all_opened,
        'target_x',    v_actual_x,
        'target_y',    v_actual_y
    );
END;
$$;













-- 8. skip_turn — пропустить ход (по таймеру)

CREATE OR REPLACE FUNCTION skip_turn(
    p_token   TEXT,
    p_game_id INT
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_login     TEXT;
    v_player_id INT;
BEGIN

    IF EXISTS (
        SELECT 1 FROM games
        WHERE gameID = p_game_id
          AND finished_at IS NOT NULL
    ) THEN
        RETURN json_build_object(
            'status','error',
            'message','Игра окончена'
        );
    END IF;

    -- 1. Проверяем токен логин
    SELECT ut.login
    INTO v_login
    FROM user_tokens ut
    WHERE ut.token = p_token;

    IF v_login IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Invalid token'
        );
    END IF;

    -- 2. Ищем игрока в этой игре
    SELECT p.playerID
    INTO v_player_id
    FROM players p
    WHERE p.gameID = p_game_id
      AND p.login  = v_login;

    IF v_player_id IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', format('Игрок %s не участвует в игре %s', v_login, p_game_id)
        );
    END IF;

    INSERT INTO moves (playerID, begin, openedTile)
    VALUES (v_player_id, clock_timestamp(), NULL);

    RETURN json_build_object(
        'status',  'success',
        'message', 'Ход пропущен по таймеру'
    );
END;
$$;














-- 9. apply_turn_timeout — серверная обработка таймаута (автоход/скип)

CREATE OR REPLACE FUNCTION apply_turn_timeout(p_game_id INT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_players_count       INT;
    v_step_time           INT;
    v_started_at          TIMESTAMP;

    v_last_move_player    INT;
    v_last_move_begin     TIMESTAMP;

    v_current_player_id   INT;
    v_current_player_num  INT;

    v_turn_started_at     TIMESTAMP;
    v_elapsed             INT;
    v_seconds_left        INT;

    v_tile_in_game_id     INT;
    v_from_x              INT;
    v_from_y              INT;
    v_type                tile_type;

    v_target_tile_in_game INT;
    v_target_x            INT;
    v_target_y            INT;
BEGIN


    IF EXISTS (
        SELECT 1 FROM games
        WHERE gameID = p_game_id
          AND finished_at IS NOT NULL
    ) THEN
        RETURN;
    END IF;


    -- Игра должна быть стартована (2 игрока)
    SELECT COUNT(*) INTO v_players_count
    FROM players
    WHERE gameID = p_game_id;

    IF v_players_count < 2 THEN
        RETURN;
    END IF;

    SELECT g.stepTime, g.started_at
    INTO v_step_time, v_started_at
    FROM games g
    WHERE g.gameID = p_game_id;

    IF v_started_at IS NULL THEN
        RETURN;
    END IF;

    -- Последний ход в этой игре
    SELECT m.playerID, m.begin
    INTO v_last_move_player, v_last_move_begin
    FROM moves m
    JOIN players p ON p.playerID = m.playerID
    WHERE p.gameID = p_game_id
    ORDER BY m.moveID DESC
    LIMIT 1;

    -- Определяем текущего игрока (кто должен ходить сейчас)
    IF v_last_move_player IS NULL THEN
        SELECT playerID, playerNumber
        INTO v_current_player_id, v_current_player_num
        FROM players
        WHERE gameID = p_game_id AND playerNumber = 1;
    ELSE
        SELECT playerNumber
        INTO v_current_player_num
        FROM players
        WHERE playerID = v_last_move_player;

        SELECT playerID
        INTO v_current_player_id
        FROM players
        WHERE gameID = p_game_id
          AND playerNumber = CASE WHEN v_current_player_num = 1 THEN 2 ELSE 1 END;
    END IF;

    IF v_current_player_id IS NULL THEN
        RETURN;
    END IF;

    -- "Начало текущего хода": либо время последнего хода, либо started_at (если ходов ещё не было)
    v_turn_started_at := COALESCE(v_last_move_begin, v_started_at);

    v_elapsed := FLOOR(EXTRACT(EPOCH FROM (now() - v_turn_started_at)))::INT;
    v_seconds_left := v_step_time - v_elapsed;

    -- Если время ещё не вышло — ничего не делаем
    IF v_seconds_left > 0 THEN
        RETURN;
    END IF;

    -- Если у текущего игрока есть "выбранный/открытый" тайл — делаем автоход
    SELECT cot.tileInGameID
    INTO v_tile_in_game_id
    FROM current_open_tiles cot
    WHERE cot.gameID = p_game_id
      AND cot.playerID = v_current_player_id;

    IF v_tile_in_game_id IS NOT NULL THEN
        -- Берём тип и координаты выбранного тайла
        SELECT t.type, tig.coordinateX, tig.coordinateY
        INTO v_type, v_from_x, v_from_y
        FROM tilesingames tig
        JOIN tiles t ON t.tileID = tig.tileID
        WHERE tig.gameID = p_game_id
          AND tig.tileInGameID = v_tile_in_game_id;

        -- Случайная допустимая цель
        IF v_type = 'prey' THEN
            SELECT tig2.tileInGameID, tig2.coordinateX, tig2.coordinateY
            INTO v_target_tile_in_game, v_target_x, v_target_y
            FROM tilesingames tig2
            WHERE tig2.gameID = p_game_id
              AND NOT (tig2.coordinateX = v_from_x AND tig2.coordinateY = v_from_y)
              AND tig2.coordinateX BETWEEN v_from_x - 1 AND v_from_x + 1
              AND tig2.coordinateY BETWEEN v_from_y - 1 AND v_from_y + 1
            ORDER BY random()
            LIMIT 1;

        ELSIF v_type = 'cat' THEN
            SELECT tig2.tileInGameID, tig2.coordinateX, tig2.coordinateY
            INTO v_target_tile_in_game, v_target_x, v_target_y
            FROM tilesingames tig2
            WHERE tig2.gameID = p_game_id
              AND (
                    (tig2.coordinateY = v_from_y AND ABS(tig2.coordinateX - v_from_x) IN (1,2))
                 OR (tig2.coordinateX = v_from_x AND ABS(tig2.coordinateY - v_from_y) IN (1,2))
              )
            ORDER BY random()
            LIMIT 1;
        END IF;

        -- Если вдруг ходить некуда — делаем skip
        IF v_target_tile_in_game IS NULL THEN
            INSERT INTO moves (playerID, begin, openedTile)
            VALUES (v_current_player_id, clock_timestamp(), NULL);

            DELETE FROM current_open_tiles
            WHERE gameID = p_game_id AND playerID = v_current_player_id;

            RETURN;
        END IF;

        -- Обмен местами (как в move_tile)
        UPDATE tilesingames
        SET coordinateX = -1, coordinateY = -1
        WHERE gameID = p_game_id AND tileInGameID = v_tile_in_game_id;

        UPDATE tilesingames
        SET coordinateX = v_from_x, coordinateY = v_from_y
        WHERE gameID = p_game_id AND tileInGameID = v_target_tile_in_game;

        UPDATE tilesingames
        SET coordinateX = v_target_x, coordinateY = v_target_y
        WHERE gameID = p_game_id AND tileInGameID = v_tile_in_game_id;

        -- Фиксируем ход
        INSERT INTO moves (playerID, begin, openedTile)
        VALUES (v_current_player_id, clock_timestamp(), v_tile_in_game_id);

        -- Сбрасываем выбранный тайл
        DELETE FROM current_open_tiles
        WHERE gameID = p_game_id AND playerID = v_current_player_id;

    ELSE
        -- Если тайл не открыт — обычный skip
        INSERT INTO moves (playerID, begin, openedTile)
        VALUES (v_current_player_id, clock_timestamp(), NULL);

        -- на всякий случай чистим
        DELETE FROM current_open_tiles
        WHERE gameID = p_game_id AND playerID = v_current_player_id;
    END IF;

    -- Если все тайлы открыты — завершаем игру
    IF (SELECT COUNT(*) FROM tilesingames WHERE gameID = p_game_id AND status = 'closed') = 0 THEN
        PERFORM finish_game(p_game_id);
    END IF;
END;
$$;














-- 10. get_game_state_json — состояние игры

CREATE OR REPLACE FUNCTION get_game_state_json(
    p_token   TEXT,
    p_game_id INT
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_login              TEXT;
    v_player_id          INT;
    v_player_number      INT;
    v_player_clan        TEXT;

    v_game_exists        BOOLEAN;
    v_step_time          INT;
    v_started_at         TIMESTAMP;
    v_finished_at        TIMESTAMP;

    v_last_move_player   INT;
    v_last_move_begin    TIMESTAMP;
    v_current_player_id  INT;
    v_turn_info          TEXT;

    v_players_count      INT;

    v_turn_started_at    TIMESTAMP;
    v_seconds_left       INT;

    -- winner/tie
    v_max_points         INT;
    v_winners_cnt        INT;
    v_winner_obj         JSON;
    v_winners_arr        JSON;
    v_is_tie             BOOLEAN;

    v_result             JSON;
BEGIN
    -- 1) токен
    SELECT ut.login
    INTO v_login
    FROM user_tokens ut
    WHERE ut.token = p_token;

    IF v_login IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Invalid token'
        );
    END IF;

    -- 2) игра существует?
    SELECT EXISTS(SELECT 1 FROM games g WHERE g.gameid = p_game_id)
    INTO v_game_exists;

    IF NOT v_game_exists THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Game not found'
        );
    END IF;

    -- 3) игрок в игре?
    SELECT p.playerid, p.playernumber, p.clan
    INTO v_player_id, v_player_number, v_player_clan
    FROM players p
    WHERE p.gameid = p_game_id
      AND p.login  = v_login;

    IF v_player_id IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'User is not in this game'
        );
    END IF;

    -- 4) базовые данные игры
    SELECT g.steptime, g.started_at, g.finished_at
    INTO v_step_time, v_started_at, v_finished_at
    FROM games g
    WHERE g.gameid = p_game_id;

    SELECT COUNT(*) INTO v_players_count
    FROM players
    WHERE gameID = p_game_id;

    v_seconds_left := NULL;
    v_turn_info := NULL;
    v_current_player_id := NULL;

    v_max_points := NULL;
    v_winners_cnt := 0;
    v_winner_obj := NULL;
    v_winners_arr := '[]'::json;
    v_is_tie := FALSE;


    -- ЕСЛИ ИГРА ОКОНЧЕНА

    IF v_finished_at IS NOT NULL THEN
        v_turn_info := 'Игра окончена';
        v_seconds_left := NULL;
        v_current_player_id := NULL;

        -- max_points
        SELECT MAX(COALESCE(playerPoints, 0))
        INTO v_max_points
        FROM players
        WHERE gameID = p_game_id;

        IF v_max_points IS NOT NULL THEN
            -- winners_cnt
            SELECT COUNT(*)
            INTO v_winners_cnt
            FROM players
            WHERE gameID = p_game_id
              AND COALESCE(playerPoints, 0) = v_max_points;

            v_is_tie := (v_winners_cnt IS NOT NULL AND v_winners_cnt > 1);

            -- winners array
            SELECT COALESCE(
                json_agg(
                    json_build_object(
                        'id',            p.playerid,
                        'login',         p.login,
                        'clan',          p.clan,
                        'player_number', p.playernumber,
                        'points',        COALESCE(p.playerpoints, 0)
                    )
                    ORDER BY p.playernumber
                ),
                '[]'::json
            )
            INTO v_winners_arr
            FROM players p
            WHERE p.gameID = p_game_id
              AND COALESCE(p.playerPoints, 0) = v_max_points;

            -- winner object (если один победитель)
            IF NOT v_is_tie THEN
                SELECT json_build_object(
                    'id',            p.playerid,
                    'login',         p.login,
                    'clan',          p.clan,
                    'player_number', p.playernumber,
                    'points',        COALESCE(p.playerpoints, 0)
                )
                INTO v_winner_obj
                FROM players p
                WHERE p.gameID = p_game_id
                  AND COALESCE(p.playerPoints, 0) = v_max_points
                ORDER BY p.playernumber
                LIMIT 1;
            END IF;
        END IF;


    -- ИНАЧЕ (ИГРА ИДЁТ)

    ELSE
        -- Автообработка таймаута (если игра стартовала)
        IF v_players_count >= 2 AND v_started_at IS NOT NULL THEN
            PERFORM apply_turn_timeout(p_game_id);
        END IF;

        -- Читаем снова последний ход
        SELECT m.playerid, m.begin
        INTO v_last_move_player, v_last_move_begin
        FROM moves m
        JOIN players p ON p.playerid = m.playerid
        WHERE p.gameid = p_game_id
        ORDER BY m.moveid DESC
        LIMIT 1;

        -- Определяем текущего игрока
        IF v_last_move_player IS NULL THEN
            SELECT p.playerid
            INTO v_current_player_id
            FROM players p
            WHERE p.gameid = p_game_id
              AND p.playernumber = 1;
        ELSE
            SELECT p.playerid
            INTO v_current_player_id
            FROM players p
            WHERE p.gameid = p_game_id
              AND p.playernumber =
                  CASE
                      WHEN (SELECT playernumber FROM players WHERE playerid = v_last_move_player) = 1
                          THEN 2
                      ELSE 1
                  END;
        END IF;

        IF v_current_player_id IS NOT NULL THEN
            SELECT format('Сейчас ход игрока #%s (%s)', p.playernumber, p.login)
            INTO v_turn_info
            FROM players p
            WHERE p.playerid = v_current_player_id;
        END IF;

        -- Секунды до конца хода
        IF v_players_count < 2 OR v_started_at IS NULL THEN
            v_seconds_left := NULL;
        ELSE
            v_turn_started_at := COALESCE(v_last_move_begin, v_started_at);
            v_seconds_left := GREATEST(
                0,
                v_step_time - FLOOR(EXTRACT(EPOCH FROM (now() - v_turn_started_at)))::INT
            );
        END IF;
    END IF;



    -- ФИНАЛЬНЫЙ JSON


    SELECT json_build_object(
        'status', 'success',

        'game', json_build_object(
            'id',        g.gameid,
            'step_time', v_step_time
        ),

        'game_finished', (v_finished_at IS NOT NULL),
        'max_points', v_max_points,
        'is_tie', COALESCE(v_is_tie, FALSE),
        'winner', v_winner_obj,
        'winners', COALESCE(v_winners_arr, '[]'::json),

        'turn_seconds_left', v_seconds_left,

        'me', json_build_object(
            'id',            v_player_id,
            'login',         v_login,
            'clan',          v_player_clan,
            'player_number', v_player_number,
            'is_my_turn',    (v_finished_at IS NULL AND v_current_player_id = v_player_id)
        ),

        'players',
        (
            SELECT COALESCE(
                json_agg(
                    json_build_object(
                        'id',               p.playerid,
                        'login',            p.login,
                        'clan',             p.clan,
                        'player_number',    p.playernumber,
                        'points',           p.playerpoints
                    )
                    ORDER BY p.playernumber
                ),
                '[]'::json
            )
            FROM players p
            LEFT JOIN clans c ON c.clanname = p.clan
            WHERE p.gameid = p_game_id
        ),

        -- tiles: ТОЛЬКО opened + ВОЗВРАЩАЕМ clan ДЛЯ ФРОНТА
        'tiles',
        (
            SELECT COALESCE(
                json_agg(
                    json_build_object(
                        'tile_in_game_id', tig.tileingameid,
                        'tile_id',         t.tileid,
                        'type',            t.type,
                        'power',           t.power,
                        'coordinateX',     tig.coordinatex,
                        'coordinateY',     tig.coordinatey,
                        'status',          tig.status,
                        'clan',            tc.clanname
                    )
                    ORDER BY tig.coordinatey, tig.coordinatex
                ),
                '[]'::json
            )
            FROM tilesingames tig
            JOIN tiles t ON t.tileid = tig.tileid
            LEFT JOIN tilesclans tc ON tc.tileid = t.tileid
            WHERE tig.gameid = p_game_id
              AND tig.status = 'opened'
        ),

        -- какой тайл уже открыт/выбран игроком в этом ходу (для восстановления selectedIndex)
        'my_open_tile',
        (
            SELECT json_build_object(
                'tile_in_game_id', tig.tileingameid,
                'coordinateX',     tig.coordinatex,
                'coordinateY',     tig.coordinatey,
                'type',            t.type,
                'clan',            tc.clanname
            )
            FROM current_open_tiles cot
            JOIN tilesingames tig ON tig.tileingameid = cot.tileingameid
            JOIN tiles t ON t.tileid = tig.tileid
            LEFT JOIN tilesclans tc ON tc.tileid = t.tileid
            WHERE cot.gameid = p_game_id
              AND cot.playerid = v_player_id
            LIMIT 1
        ),

        'turn_info', v_turn_info
    )
    INTO v_result
    FROM games g
    WHERE g.gameid = p_game_id;

    RETURN v_result;
END;
$$;










-- 11. get_rooms_json — список комнат для лобби

CREATE OR REPLACE FUNCTION get_rooms_json(p_token TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_login  TEXT;
    v_result JSON;
BEGIN
    -- Проверяем токен
    SELECT login
    INTO v_login
    FROM user_tokens
    WHERE token = p_token;

    IF v_login IS NULL THEN
        RETURN json_build_object(
            'status',  'error',
            'message', 'Invalid token'
        );
    END IF;

    -- Только "открытые" комнаты: где игроков ровно 1
    SELECT json_build_object(
        'status', 'success',
        'rooms',
        COALESCE(
            (
                SELECT json_agg(
                    json_build_object(
                        'game_id', r.gameid,
                        -- "opponent" = кто уже сидит в комнате и ждёт (единственный игрок)
                        'opponent', r.waiting_login
                    )
                    ORDER BY r.gameid
                )
                FROM (
                    SELECT
                        p.gameid,
                        MIN(p.login) AS waiting_login
                    FROM players p
                    GROUP BY p.gameid
                    HAVING COUNT(*) = 1
                ) r
            ),
            '[]'::json
        )
    )
    INTO v_result;

    RETURN v_result;
END;
$$;








-- 12. finish_game — подсчет очков

CREATE OR REPLACE FUNCTION finish_game(p_game_id INT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    prey_rec       RECORD;      -- одна добыча за раз
    v_winner_clan  VARCHAR(50); -- клан, который победил вокруг этой добычи
    v_winner_power INT;         -- суммарная сила котов-победителей вокруг добычи
    v_num_top      INT;         -- сколько кланов делят максимум (чтобы отловить ничью)
BEGIN
    -- 1. Сбрасываем очки всех игроков в этой игре
    -- (функция становится идемпотентной: если её вызвать ещё раз, всё пересчитается заново)
    UPDATE players
    SET playerPoints = 0
    WHERE gameID = p_game_id;

    -- 2. Для каждого тайла ДОБЫЧИ считаем, кто контролирует его по силе котов вокруг
    FOR prey_rec IN
        SELECT tig.tileInGameID,
               tig.coordinateX,
               tig.coordinateY,
               t.power AS prey_power
        FROM tilesingames tig
        JOIN tiles t ON t.tileID = tig.tileID
        WHERE tig.gameID = p_game_id
          AND t.type = 'prey'
    LOOP
        v_winner_clan  := NULL;
        v_winner_power := NULL;
        v_num_top      := 0;

        -- Считаем суммарную силу котов каждого клана вокруг этой добычи
        WITH clan_scores AS (
            SELECT tc.clanName,
                   SUM(t_cat.power) AS total_power
            FROM tilesingames tig_cat
            JOIN tiles       t_cat ON t_cat.tileID = tig_cat.tileID
            JOIN tilesclans  tc    ON tc.tileID    = t_cat.tileID
            WHERE tig_cat.gameID = p_game_id
              AND t_cat.type     = 'cat'
              AND (
                    (tig_cat.coordinateX = prey_rec.coordinateX + 1 AND tig_cat.coordinateY = prey_rec.coordinateY    ) OR
                    (tig_cat.coordinateX = prey_rec.coordinateX - 1 AND tig_cat.coordinateY = prey_rec.coordinateY    ) OR
                    (tig_cat.coordinateX = prey_rec.coordinateX     AND tig_cat.coordinateY = prey_rec.coordinateY + 1) OR
                    (tig_cat.coordinateX = prey_rec.coordinateX     AND tig_cat.coordinateY = prey_rec.coordinateY - 1)
                  )
            GROUP BY tc.clanName
        ),
        max_score AS (
            SELECT MAX(total_power) AS mx FROM clan_scores
        )
        SELECT cs.clanName,
               cs.total_power,
               (
                   SELECT COUNT(*)
                   FROM clan_scores
                   WHERE total_power = ms.mx
               ) AS num_top
        INTO v_winner_clan, v_winner_power, v_num_top
        FROM clan_scores cs
        CROSS JOIN max_score ms
        WHERE cs.total_power = ms.mx
        LIMIT 1;

        -- Если:
        --  • котов вокруг добычи нет
        --  • или несколько кланов делят максимальную силу (ничья)
        --  • или суммарная сила не положительна
        -- → эту добычу никто не получает
        IF v_winner_clan IS NULL
           OR v_num_top IS NULL
           OR v_num_top <> 1
           OR v_winner_power IS NULL
           OR v_winner_power <= 0
        THEN
            CONTINUE;
        END IF;

        -- 3. Клан-победитель вокруг этой добычи получает ЕЁ силу в очки
        -- (каждый игрок этого клана в игре получает +prey_power)
        UPDATE players
        SET playerPoints = COALESCE(playerPoints, 0) + prey_rec.prey_power
        WHERE gameID = p_game_id
          AND clan   = v_winner_clan;
    END LOOP;
END;
$$;






-- 13. leave_game — выйти из игры (до старта: выход и удаление комнаты; во время игры: сдача/форфейт; после конца: ничего не меняем)


CREATE OR REPLACE FUNCTION leave_game(
    p_token   TEXT,
    p_game_id INT
) RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_login         TEXT;
    v_player_id     INT;
    v_finished_at   TIMESTAMP;
    v_players_count INT;
BEGIN
    -- токен -> логин
    SELECT ut.login INTO v_login
    FROM user_tokens ut
    WHERE ut.token = p_token;

    IF v_login IS NULL THEN
        RETURN json_build_object('status','error','message','Invalid token');
    END IF;

    -- игра существует?
    PERFORM 1 FROM games g WHERE g.gameID = p_game_id;
    IF NOT FOUND THEN
        RETURN json_build_object('status','error','message','Game not found');
    END IF;

    -- игрок в игре?
    SELECT p.playerID INTO v_player_id
    FROM players p
    WHERE p.gameID = p_game_id
      AND p.login  = v_login;

    IF v_player_id IS NULL THEN
        RETURN json_build_object('status','error','message','User is not in this game');
    END IF;

    -- игра окончена?
    SELECT g.finished_at INTO v_finished_at
    FROM games g
    WHERE g.gameID = p_game_id;

    SELECT COUNT(*) INTO v_players_count
    FROM players
    WHERE gameID = p_game_id;

    -- CASE 1: уже закончена
    IF v_finished_at IS NOT NULL THEN
        RETURN json_build_object('status','success','action','view_exit','message','Game already finished');
    END IF;

    -- CASE 2: второй игрок не зашёл -> удаляем игру
    IF v_players_count < 2 THEN
        DELETE FROM current_open_tiles WHERE gameID = p_game_id;

        DELETE FROM moves m
        USING players p
        WHERE m.playerID = p.playerID
          AND p.gameID = p_game_id;

        DELETE FROM tilesingames WHERE gameID = p_game_id;
        DELETE FROM players     WHERE gameID = p_game_id;
        DELETE FROM games       WHERE gameID = p_game_id;

        RETURN json_build_object('status','success','action','deleted_unstarted_game','message','Game deleted (no second player)');
    END IF;

    -- CASE 3: игра идёт -> форфейт
    UPDATE games
    SET finished_at = now()
    WHERE gameID = p_game_id
      AND finished_at IS NULL;

    DELETE FROM current_open_tiles WHERE gameID = p_game_id;

    UPDATE players SET playerPoints = 0
    WHERE gameID = p_game_id AND login = v_login;

    UPDATE players SET playerPoints = 1
    WHERE gameID = p_game_id AND login <> v_login;

    RETURN json_build_object('status','success','action','forfeit_finished','message','Player forfeited, game finished');
END;
$$;









